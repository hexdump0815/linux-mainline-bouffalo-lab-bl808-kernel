from: https://github.com/bouffalolab/linux-dev/commit/eef3f8486f274c368654014fff05f4b4ec423adb

From eef3f8486f274c368654014fff05f4b4ec423adb Mon Sep 17 00:00:00 2001
From: qhli <qhli@bouffalolab.com>
Date: Tue, 7 Nov 2023 11:05:29 +0800
Subject: [PATCH] ENH: refactor bl808 pinctrl

	1. Have a new style pinctrl in dts, refer to doc please.
	2. Implement bl808 pinconf_ops, then functions of GPIO chip driver
	   can use generic pinctrl-gpio interfaces rather than repeating the work.
	3. Fix potential UAF meory usage of gpio_chip->parents.
	4. Fix invalid usage of bpctl->grps which is never allocated.

Signed-off-by: qhli <qhli@bouffalolab.com>
---
 .../bindings/pinctrl/pinctrl-bflb.txt         |   46 +
 .../dts/bouffalolab/bl808-pine64-ox64.dts     |    4 +-
 .../boot/dts/bouffalolab/bl808-sipeed-m1s.dts |   22 +-
 arch/riscv/boot/dts/bouffalolab/bl808.dtsi    |   84 +-
 drivers/pinctrl/pinctrl-bflb.c                | 1174 +++++++++++------
 include/dt-bindings/pinctrl/pinctrl-bflb.h    |   40 +
 6 files changed, 934 insertions(+), 436 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/pinctrl/pinctrl-bflb.txt
 create mode 100644 include/dt-bindings/pinctrl/pinctrl-bflb.h

diff --git a/Documentation/devicetree/bindings/pinctrl/pinctrl-bflb.txt b/Documentation/devicetree/bindings/pinctrl/pinctrl-bflb.txt
new file mode 100644
index 000000000..9d7f62caf
--- /dev/null
+++ b/Documentation/devicetree/bindings/pinctrl/pinctrl-bflb.txt
@@ -0,0 +1,46 @@
+Bouffalo Lab pinctrl driver.
+
+driver compatible name: bflb,bl808-pinctrl.
+
+device tree properties:
+bflb,pin-function: ref include/dt-bindings/pinctrl/pinctrl-bflb.h
+bflb,pins: format <bank_idx pin_number config_phandle>,
+	where bank_idx is always 0 at present,
+	pin_number is the pin offset,
+	config_phandle is a phandle to node with one or multiple standard or
+	hardware specific configurations.
+
+For example:
+pinctrl: pinctrl@0 {
+	compatible = "bflb,bl808-pinctrl";
+	status = "okay";
+	...
+
+	pin_cfg_default: pin-cfg-default {
+		bias-pull-pin-default;
+		output-enable;
+		input-enable;
+	};
+
+	mm_uart_pins: mm-uart-grp0 {
+		bflb,pins = <0 16 &pin_cfg_default>,
+					<0 17 &pin_cfg_default>;
+		bflb,pin-function = <BFLB_PINMUX_FUNC_MM_UART>;
+	};
+
+	spi_foo_pins: mm-spi-grp0 {
+		bflb,pins = <0 20 &pin_cfg_default>,
+					<0 21 &pin_cfg_default>,
+					<0 22 &pin_cfg_default>,
+					<0 23 &pin_cfg_default>;
+		bflb,pin-function = <BFLB_PINMUX_FUNC_MM_SPI>;
+	};
+
+	spi_bar_pins: mm-spi-grp1 {
+		bflb,pins = <0 20 &pin_cfg_default>,
+					<0 21 &pin_cfg_default>,
+					<0 22 &pin_cfg_default>,
+					<0 23 &pin_cfg_default>;
+		bflb,pin-function = <BFLB_PINMUX_FUNC_MM_SPI>;
+	};
+};
diff --git a/arch/riscv/boot/dts/bouffalolab/bl808-pine64-ox64.dts b/arch/riscv/boot/dts/bouffalolab/bl808-pine64-ox64.dts
index 1035f7619..d4d13a89d 100644
--- a/arch/riscv/boot/dts/bouffalolab/bl808-pine64-ox64.dts
+++ b/arch/riscv/boot/dts/bouffalolab/bl808-pine64-ox64.dts
@@ -12,7 +12,7 @@
 	compatible = "pine64,ox64", "bflb,bl808";
 
 	aliases {
-		serial0 = &uart0;
+		serial0 = &mm_uart;
 		serial1 = &uart1;
 	};
 
@@ -54,7 +54,7 @@
 	status = "okay";
 };
 
-&uart0 {
+&mm_uart {
 	status = "okay";
 };
 
diff --git a/arch/riscv/boot/dts/bouffalolab/bl808-sipeed-m1s.dts b/arch/riscv/boot/dts/bouffalolab/bl808-sipeed-m1s.dts
index f168459d2..9a2b38c25 100644
--- a/arch/riscv/boot/dts/bouffalolab/bl808-sipeed-m1s.dts
+++ b/arch/riscv/boot/dts/bouffalolab/bl808-sipeed-m1s.dts
@@ -8,13 +8,14 @@
 #include "bl808.dtsi"
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/pinctrl-bflb.h>
 
 / {
 	model = "Sipeed M1s";
 	compatible = "sipeed,m1s", "bflb,bl808";
 
 	aliases {
-		serial0 = &uart0;
+		serial0 = &mm_uart;
 	};
 
 	chosen {
@@ -58,7 +59,7 @@
 	pwm-leds {
 		compatible = "pwm-leds";
 		pinctrl-names = "default";
-		pinctrl-0 = <&pwm_led>;
+		pinctrl-0 = <&pwm_led_pins>;
 		status = "okay";
 
 		led-0 {
@@ -73,14 +74,15 @@
 &pinctrl {
 	status = "okay";
 
-	led {
-		pins = "GPIO8";
-		function = "gpio";
+	pwm_led_pins: pwm0-grp0 {
+		bflb,pin-function = <BFLB_PINMUX_FUNC_PWM0>;
+		bflb,pins = <0 8 &pin_cfg_default>;
 	};
 
-	pwm_led: pwm_led {
-		pins = "GPIO8";
-		function = "pwm0";
+	mm_uart_pins: mm-uart-grp0 {
+		bflb,pin-function = <BFLB_PINMUX_FUNC_MM_UART>;
+		bflb,pins = <0 16 &pin_cfg_default>,
+					<0 17 &pin_cfg_default>;
 	};
 };
 
@@ -88,8 +90,10 @@
 	status = "okay";
 };
 
-&uart0 {
+&mm_uart {
 	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mm_uart_pins>;
 };
 
 &sdhci0 {
diff --git a/arch/riscv/boot/dts/bouffalolab/bl808.dtsi b/arch/riscv/boot/dts/bouffalolab/bl808.dtsi
index 96c208ec0..0fec2768b 100644
--- a/arch/riscv/boot/dts/bouffalolab/bl808.dtsi
+++ b/arch/riscv/boot/dts/bouffalolab/bl808.dtsi
@@ -1,10 +1,11 @@
 // SPDX-License-Identifier: (GPL-2.0+ or MIT)
 /*
- * Copyright (C) 2022 Jisheng Zhang <jszhang@kernel.org>
+ * Copyright (C) 2023 Bouffalo Lab
  */
 
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/mailbox/bflb-ipc.h>
+#include <dt-bindings/pinctrl/pinctrl-bflb.h>
 
 / {
 	compatible = "bflb,bl808";
@@ -61,25 +62,86 @@
 		#size-cells = <1>;
 
 		pinctrl: pinctrl@0x200008C4 {
-			compatible = "bflb,pinctrl";
-			//Last register is for gpio_cfg141 at 0x20000af8
+			compatible = "bflb,bl808-pinctrl";
 			reg = <0x200008C4 0x1000>;
 			//clocks = <&gpio_clk>;
+			status = "disabled";
 
 			gpio-controller;
 			#gpio-cells = <2>;
 			gpio-ranges = <&pinctrl 0 0 46>;
-			bflb,npins = <46>;
-
-			status = "disabled";
 
 			interrupt-controller;
 			#interrupt-cells = <2>;
 			interrupts-extended = <&m0ic 44>;
 
-			sdh_pins: sdh-pins {
-				pins = "GPIO0", "GPIO1", "GPIO2", "GPIO3", "GPIO4", "GPIO5";
-				function = "sdh";
+			/*
+			 * developers should define their own pin config nodes with
+			 * multiple properties if the requirements are not met using
+			 * the following basic ones.
+			 */
+			pin_cfg_default: pin-cfg-default {
+				bias-pull-pin-default;
+			};
+
+			pin_cfg_pullup: pin-cfg-pullup {
+				bias-pull-up;
+			};
+
+			pin_cfg_pulldown: pin-cfg-pulldown {
+				bias-pull-down;
+			};
+
+			pin_cfg_input_enable: pin-cfg-input-enable {
+				input-enable;
+			};
+
+			pin_cfg_output_enable: pin-cfg-output-enable {
+				output-enable;
+			};
+
+			pin_cfg_output_high: pin-cfg-output-high {
+				output-high;
+			};
+
+			pin_cfg_output_low: pin-cfg-output-low {
+				output-low;
+			};
+
+			pin_cfg_strength_0: pin-cfg-strength-0 {
+				drive-strength = <0>;
+			};
+
+			pin_cfg_strength_1: pin-cfg-strength-1 {
+				drive-strength = <1>;
+			};
+
+			pin_cfg_strength_2: pin-cfg-strength-2 {
+				drive-strength = <2>;
+			};
+
+			pin_cfg_strength_3: pin-cfg-strength-3 {
+				drive-strength = <3>;
+			};
+
+			sdh_pins: sdh-grp0 {
+				bflb,pin-function = <BFLB_PINMUX_FUNC_SDH>;
+				bflb,pins = <0 0 &pin_cfg_strength_2>,
+							<0 1 &pin_cfg_strength_2>,
+							<0 2 &pin_cfg_strength_2>,
+							<0 3 &pin_cfg_strength_2>,
+							<0 4 &pin_cfg_strength_2>,
+							<0 5 &pin_cfg_strength_2>;
+			};
+
+			qspi_flash_pins: qspi-flash-grp0 {
+				bflb,pin-function = <BFLB_PINMUX_FUNC_QSPI_FLASH>;
+				bflb,pins = <0 34 &pin_cfg_default>,
+							<0 35 &pin_cfg_default>,
+							<0 36 &pin_cfg_default>,
+							<0 37 &pin_cfg_default>,
+							<0 38 &pin_cfg_default>,
+							<0 39 &pin_cfg_default>;
 			};
 		};
 
@@ -89,7 +151,7 @@
 			status = "disabled";
 		};
 
-		uart0: serial@30002000 {
+		mm_uart: serial@30002000 {
 			compatible = "bflb,bl808-uart";
 			reg = <0x30002000 0x1000>;
 			interrupts = <20 IRQ_TYPE_LEVEL_HIGH>;
@@ -111,6 +173,8 @@
 			interrupts-extended = <&m0ic 17>;
 			clocks = <&sdh>;
 			status = "disabled";
+			pinctrl-names = "default";
+			pinctrl-0 = <&sdh_pins>;
 		};
 
 		pwm0: pwm@2000a440 {
diff --git a/drivers/pinctrl/pinctrl-bflb.c b/drivers/pinctrl/pinctrl-bflb.c
index 4223fcc18..787452f5f 100644
--- a/drivers/pinctrl/pinctrl-bflb.c
+++ b/drivers/pinctrl/pinctrl-bflb.c
@@ -1,14 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Bouffalo Lab SoC pinctrl+GPIO+external IRQ driver
+ * Bouffalo Lab SoC pinctrl + GPIO + external IRQ controller driver
  *
- * Based on: pinctrl-apple-gpio.c
- * Copyright (C) The Asahi Linux Contributors
- * Copyright (C) 2020 Corellium LLC
+ * 2023.11 - BL808
  *
- * Based on: pinctrl-pistachio.c
- * Copyright (C) 2014 Imagination Technologies Ltd.
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2016-2023
  */
 
 #include <linux/bitfield.h>
@@ -21,17 +17,46 @@
 #include <linux/of_irq.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
-
 #include <linux/pinctrl/consumer.h>
 #include <linux/pinctrl/pinconf-generic.h>
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/pinctrl/pinmux.h>
-
+#include <linux/pinctrl/pinconf.h>
+#include <dt-bindings/pinctrl/pinctrl-bflb.h>
 #include "pinctrl-utils.h"
 #include "core.h"
 #include "pinmux.h"
+#include "pinconf.h"
+
+struct bflb_pinfunction {
+	const char *name;
+	const char **groups;
+	unsigned int ngroups;
+	/* capacity of group memory */
+	unsigned int ncap;
+	/* the value to be programmed into register */
+	u32 val;
+};
+
+struct bflb_pinconf {
+	unsigned long *configs;
+	unsigned int nconfigs;
+};
+
+struct bflb_pingroup {
+	const char *name;
+	unsigned int *pins;
+	size_t npins;
+	/*
+	 * this is built when driver probes device and only used in dt_node_to_map
+	 * to accelerate the process.
+	 */
+	struct bflb_pinconf *pinconf;
+	/* the function value of the group */
+	u32 fn_val;
+};
 
-struct bflb_gpio_pinctrl {
+struct bflb_pinctrl_info {
 	struct device *dev;
 	struct pinctrl_dev *pctldev;
 
@@ -41,32 +66,37 @@ struct bflb_gpio_pinctrl {
 	struct pinctrl_desc pinctrl_desc;
 	struct gpio_chip gpio_chip;
 
-	void *irqsunmasked;
-	u8 irqgrps[];
+	/* pin groups and functions */
+	struct bflb_pingroup *groups;
+	int ngroups;
+	struct bflb_pinfunction *functions;
+	int nfunctions;
+
+	void *unmasked_irqs;
 };
 
-//Register indexing
-#define REG_GPIO(x)              (4 * (x))
-
-//Register map
-#define REG_GPIOx_MODE           GENMASK(31, 30)
-#define REG_GPIOx_I              BIT(28)
-#define REG_GPIOx_CLR            BIT(26)
-#define REG_GPIOx_SET            BIT(25)
-#define REG_GPIOx_O              BIT(24)
-#define REG_GPIOx_INT_MASK       BIT(22)
-#define REG_GPIOx_INT_STAT       BIT(21)
-#define REG_GPIOx_INT_CLR        BIT(20)
-#define REG_GPIOx_INT_MODE_SET   GENMASK(29, 16)
-#define REG_GPIOx_FUNC_SEL       GENMASK(12, 8)
-#define REG_GPIOx_OE             BIT(6)
-#define REG_GPIOx_PD             BIT(5)
-#define REG_GPIOx_PU             BIT(4)
-#define REG_GPIOx_DRV            GENMASK(3, 2)
-#define REG_GPIOx_SMT            BIT(1)
-#define REG_GPIOx_IE             BIT(0)
-
-//Interrupt trigger modes
+/* register indexing */
+#define REG_PIN(x)              (4 * (x))
+
+/* register map */
+#define REG_PIN_MODE_MASK      GENMASK(31, 30)
+#define REG_PIN_IN_HIGH        BIT(28)
+#define REG_PIN_CLR            BIT(26)
+#define REG_PIN_SET            BIT(25)
+#define REG_PIN_OUT_HIGH       BIT(24)
+#define REG_PIN_INT_MASK       BIT(22)
+#define REG_PIN_INT_STAT       BIT(21)
+#define REG_PIN_INT_CLR        BIT(20)
+#define REG_PIN_INT_MODE_SET   GENMASK(19, 16)
+#define REG_PIN_FUNC_SEL       GENMASK(12, 8)
+#define REG_PIN_OE             BIT(6)
+#define REG_PIN_PD             BIT(5)
+#define REG_PIN_PU             BIT(4)
+#define REG_PIN_DRV            GENMASK(3, 2)
+#define REG_PIN_SMT            BIT(1)
+#define REG_PIN_IE             BIT(0)
+
+/* interrupt trigger modes */
 #define BFLB_IRQ_MODE_SYNC_EDGE_FALLING  0
 #define BFLB_IRQ_MODE_SYNC_EDGE_RISING   1
 #define BFLB_IRQ_MODE_SYNC_LEVEL_LOW     2
@@ -78,33 +108,70 @@ struct bflb_gpio_pinctrl {
 #define BFLB_IRQ_MODE_ASYNC_LEVEL_LOW    10
 #define BFLB_IRQ_MODE_ASYNC_LEVEL_HIGH   11
 
-static const char * const pinmux_functions[] = {
-	//AH: As taken from smaeul's pinctrl-bflb.c for U-Boot
-	[0]	    = "sdh",
-	[1]	    = "spi0",
-	[2]	    = "flash",
-	[3]	    = "i2s",
-	[4]	    = "pdm",
-	[5]	    = "i2c0",
-	[6]	    = "i2c1",
-	[7]	    = "uart",
-	[8]	    = "emac",
-	[9]	    = "cam",
-	[10]	= "analog",
-	[11]	= "gpio",
-	[16]	= "pwm0",
-	[17]	= "pwm1",
-	[18]	= "spi1",	// mm_spi
-	[19]	= "i2c2",	// mm_i2c0
-	[20]	= "i2c3",	// mm_i2c1
-	[21]	= "mm_uart",
-	[22]	= "dbi_b",
-	[23]	= "dbi_c",
-	[24]	= "dpi",
-	[25]	= "jtag_lp",
-	[26]	= "jtag_m0",
-	[27]	= "jtag_d0",
-	[31]	= "clock",
+static const struct pinctrl_pin_desc bl808_pins[] = {
+	PINCTRL_PIN(0, "PIN0"),   PINCTRL_PIN(1, "PIN1"),
+	PINCTRL_PIN(2, "PIN2"),   PINCTRL_PIN(3, "PIN3"),
+	PINCTRL_PIN(4, "PIN4"),   PINCTRL_PIN(5, "PIN5"),
+	PINCTRL_PIN(6, "PIN6"),   PINCTRL_PIN(7, "PIN7"),
+	PINCTRL_PIN(8, "PIN8"),   PINCTRL_PIN(9, "PIN9"),
+	PINCTRL_PIN(10, "PIN10"), PINCTRL_PIN(11, "PIN11"),
+	PINCTRL_PIN(12, "PIN12"), PINCTRL_PIN(13, "PIN13"),
+	PINCTRL_PIN(14, "PIN14"), PINCTRL_PIN(15, "PIN15"),
+	PINCTRL_PIN(16, "PIN16"), PINCTRL_PIN(17, "PIN17"),
+	PINCTRL_PIN(18, "PIN18"), PINCTRL_PIN(19, "PIN19"),
+	PINCTRL_PIN(20, "PIN20"), PINCTRL_PIN(21, "PIN21"),
+	PINCTRL_PIN(22, "PIN22"), PINCTRL_PIN(23, "PIN23"),
+	PINCTRL_PIN(24, "PIN24"), PINCTRL_PIN(25, "PIN25"),
+	PINCTRL_PIN(26, "PIN26"), PINCTRL_PIN(27, "PIN27"),
+	PINCTRL_PIN(28, "PIN28"), PINCTRL_PIN(29, "PIN29"),
+	PINCTRL_PIN(30, "PIN30"), PINCTRL_PIN(31, "PIN31"),
+	PINCTRL_PIN(32, "PIN32"), PINCTRL_PIN(33, "PIN33"),
+	PINCTRL_PIN(34, "PIN34"), PINCTRL_PIN(35, "PIN35"),
+	PINCTRL_PIN(36, "PIN36"), PINCTRL_PIN(37, "PIN37"),
+	PINCTRL_PIN(38, "PIN38"), PINCTRL_PIN(39, "PIN39"),
+	PINCTRL_PIN(40, "PIN40"), PINCTRL_PIN(41, "PIN41"),
+	PINCTRL_PIN(42, "PIN42"), PINCTRL_PIN(43, "PIN43"),
+	PINCTRL_PIN(44, "PIN44"), PINCTRL_PIN(45, "PIN45")
+};
+
+struct bflb_function_desc {
+	unsigned int val;
+	const char *name;
+};
+
+static const struct bflb_function_desc bl808_functions[] = {
+	{BFLB_PINMUX_FUNC_SDH,			"sdh"},
+	{BFLB_PINMUX_FUNC_SPI0,			"spi0"},
+	{BFLB_PINMUX_FUNC_QSPI_FLASH,	"qspi_flash"},
+	{BFLB_PINMUX_FUNC_I2S,			"i2s"},
+	{BFLB_PINMUX_FUNC_PDM,			"pdm"},
+	{BFLB_PINMUX_FUNC_I2C0,			"i2c0"},
+	{BFLB_PINMUX_FUNC_I2C1,			"i2c1"},
+	{BFLB_PINMUX_FUNC_UART,			"uart"},
+	{BFLB_PINMUX_FUNC_EMAC,			"emac"},
+	{BFLB_PINMUX_FUNC_CAM,			"cam"},
+	{BFLB_PINMUX_FUNC_ANALOG,		"analog"},
+	{BFLB_PINMUX_FUNC_GPIO,			"gpio"},
+	{BFLB_PINMUX_FUNC_RF_ADDA,		"rf_adda"},
+	{BFLB_PINMUX_FUNC_SCAN_TEST,	"scan_test"},
+	{BFLB_PINMUX_FUNC_AUDIO_TEST,	"audio_test"},
+	{BFLB_PINMUX_FUNC_DEBUG,		"debug"},
+	{BFLB_PINMUX_FUNC_PWM0,			"pwm0"},
+	{BFLB_PINMUX_FUNC_PWM1,			"pwm1"},
+	{BFLB_PINMUX_FUNC_MM_SPI,		"mm_spi"},
+	{BFLB_PINMUX_FUNC_MM_I2C0,		"mm_i2c0"},
+	{BFLB_PINMUX_FUNC_MM_I2C1,		"mm_i2c1"},
+	{BFLB_PINMUX_FUNC_MM_UART,		"mm_uart"},
+	{BFLB_PINMUX_FUNC_DBI_B,		"dbi_b"},
+	{BFLB_PINMUX_FUNC_DBI_C,		"dbi_c"},
+	{BFLB_PINMUX_FUNC_DPI,			"dpi"},
+	{BFLB_PINMUX_FUNC_JTAG_LP,		"jtag_lp"},
+	{BFLB_PINMUX_FUNC_JTAG_M0,		"jtag_m0"},
+	{BFLB_PINMUX_FUNC_JTAG_D0,		"jtag_d0"},
+	{BFLB_PINMUX_FUNC_RF_EXT_PA,	"rf_ext_pa"},
+	{BFLB_PINMUX_FUNC_ANT_SW,		"ant_switch"},
+	{BFLB_PINMUX_FUNC_USB_TEST,		"usb_test"},
+	{BFLB_PINMUX_FUNC_CLOCK,		"clock"},
 };
 
 struct regmap_config regmap_config = {
@@ -118,380 +185,585 @@ struct regmap_config regmap_config = {
 	.use_raw_spinlock = true,
 };
 
-//AH: Set raw gpio config register bits based on mask
-static void bflb_gpio_set_reg(struct bflb_gpio_pinctrl *pctl, unsigned int pin,
-		u32 mask, u32 value)
+static int bflb_pinctrl_get_group_count(struct pinctrl_dev *pctldev)
 {
-	regmap_update_bits(pctl->map, REG_GPIO(pin), mask, value);
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
+
+	return bpctl->ngroups;
 }
 
-//AH: Get raw gpio config register bits
-static u32 bflb_gpio_get_reg(struct bflb_gpio_pinctrl *pctl, unsigned int pin)
+static const char *bflb_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
+		unsigned int selector)
 {
-	int ret;
-	u32 val;
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
 
-	ret = regmap_read(pctl->map, REG_GPIO(pin), &val);
+	return bpctl->groups[selector].name;
+}
 
-	if (ret)
-		return 0;
+static int bflb_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
+		unsigned int selector, const unsigned int **pins, unsigned int *num_pins)
+{
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
 
-	return val;
+	*pins = bpctl->groups[selector].pins;
+	*num_pins = bpctl->groups[selector].npins;
+	return 0;
 }
 
-/* Pin controller functions */
-
-static const struct pinctrl_ops bflb_gpio_pinctrl_ops = {
-	.get_groups_count = pinctrl_generic_get_group_count,
-	.get_group_name   = pinctrl_generic_get_group_name,
-	.get_group_pins   = pinctrl_generic_get_group_pins,
-	.dt_node_to_map   = pinconf_generic_dt_node_to_map_group,
-	.dt_free_map      = pinconf_generic_dt_free_map,
-};
+static struct bflb_pingroup *bflb_pinctrl_name_to_group(
+	struct bflb_pinctrl_info *bpctrl, const char *name)
+{
+	int i;
+	struct bflb_pingroup *grp;
 
-/* Pin multiplexer functions */
+	for (i = 0; i < bpctrl->ngroups; i++) {
+		grp = &bpctrl->groups[i];
+		if (!strcmp(name, grp->name))
+			return grp;
+	}
+	return NULL;
+}
 
-//AH: Configure gpio modes and features
-static int bflb_gpio_pinmux_set(struct pinctrl_dev *pctldev, unsigned int func,
-		unsigned int group)
+static struct bflb_pinfunction *bflb_pinctrl_parse_function(
+		struct bflb_pinctrl_info *bpctl, u32 func_val)
 {
-	struct bflb_gpio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	int i;
+
+	for (i = 0; i < bpctl->nfunctions; i++) {
+		if (func_val == bpctl->functions[i].val)
+			return &bpctl->functions[i];
+	}
+
+	return NULL;
+}
 
-	bflb_gpio_set_reg(pctl, group, REG_GPIOx_FUNC_SEL,
-		FIELD_PREP(REG_GPIOx_FUNC_SEL, func));
+static int bflb_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,
+		struct device_node *np, struct pinctrl_map **map, unsigned int *num_maps)
+{
+	int err;
+	struct bflb_pingroup *grp;
+	struct bflb_pinfunction *func;
+	unsigned int i, reserve, map_idx = 0;
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
+
+	*map = NULL;
+	*num_maps = 0;
+
+	grp = bflb_pinctrl_name_to_group(bpctl, np->name);
+	if (!grp) {
+		dev_err(bpctl->dev, "unable to find group for node %pOFn\n", np);
+		return -EINVAL;
+	}
 
-	dev_dbg(pctl->dev, "Pin %u set to function %u", group, func);
+	/* pin group mux map + pin config map x npins */
+	reserve = 1 + grp->npins;
+	err = pinctrl_utils_reserve_map(pctldev, map, num_maps, &map_idx, reserve);
+	if (err)
+		return err;
+
+	func = bflb_pinctrl_parse_function(bpctl, grp->fn_val);
+	err = pinctrl_utils_add_map_mux(pctldev, map, num_maps, &map_idx, grp->name,
+									func->name);
+	if (err)
+		goto exit;
+
+	for (i = 0; i < grp->npins; i++) {
+		struct bflb_pinconf *conf = &grp->pinconf[i];
+		const char *pin_name = pin_get_name(pctldev, grp->pins[i]);
+
+		err = pinctrl_utils_add_map_configs(pctldev, map, num_maps, &map_idx,
+				pin_name, conf->configs, conf->nconfigs,
+				PIN_MAP_TYPE_CONFIGS_PIN);
+		if (err)
+			goto exit;
+	}
 
+	*num_maps = map_idx;
 	return 0;
+
+exit:
+	pinctrl_utils_free_map(pctldev, *map, map_idx);
+	return err;
 }
 
-static const struct pinmux_ops bflb_gpio_pinmux_ops = {
-	.get_functions_count = pinmux_generic_get_function_count,
-	.get_function_name = pinmux_generic_get_function_name,
-	.get_function_groups = pinmux_generic_get_function_groups,
-	.set_mux = bflb_gpio_pinmux_set,
-	.strict = true,
+/* pin controller functions */
+static const struct pinctrl_ops bflb_pinctrl_ops = {
+	.get_groups_count = bflb_pinctrl_get_group_count,
+	.get_group_name   = bflb_pinctrl_get_group_name,
+	.get_group_pins   = bflb_pinctrl_get_group_pins,
+	.dt_node_to_map   = bflb_pinctrl_dt_node_to_map,
+	.dt_free_map      = pinctrl_utils_free_map,
 };
 
-/* GPIO chip functions */
-
-//AH: Get the current gpio direction
-static int bflb_gpio_get_direction(struct gpio_chip *chip,
-		unsigned int offset)
+/* pin multiplexer functions */
+static int bflb_pinmux_get_functions_count(struct pinctrl_dev *pctldev)
 {
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(chip);
-	unsigned int reg = bflb_gpio_get_reg(pctl, offset);
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
 
-	if (FIELD_GET(REG_GPIOx_OE, reg) == 1 &&
-			FIELD_GET(REG_GPIOx_IE, reg) == 0) {
-		return GPIO_LINE_DIRECTION_OUT;
-	} else if (FIELD_GET(REG_GPIOx_IE, reg) == 1 &&
-			FIELD_GET(REG_GPIOx_OE, reg) == 0) {
-		return GPIO_LINE_DIRECTION_IN;
-	}
-
-	return -EIO;
+	return bpctl->nfunctions;
 }
 
-//AH: Get the incoming input or outgoing output value for the specified GPIO
-static int bflb_gpio_get(struct gpio_chip *chip, unsigned int offset)
+static const char *bflb_pinmux_get_function_name(struct pinctrl_dev *pctldev,
+					  unsigned int selector)
 {
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(chip);
-	unsigned int reg = bflb_gpio_get_reg(pctl, offset);
-
-	if (FIELD_GET(REG_GPIOx_OE, reg) == 1 &&
-			FIELD_GET(REG_GPIOx_IE, reg) == 0) {
-		reg = readl_relaxed(pctl->base + REG_GPIO(offset));
-		return !!(reg & REG_GPIOx_O);
-	} else if (FIELD_GET(REG_GPIOx_IE, reg) == 1 &&
-			FIELD_GET(REG_GPIOx_OE, reg) == 0) {
-		reg = readl_relaxed(pctl->base + REG_GPIO(offset));
-		return !!(reg & REG_GPIOx_I);
-	}
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
 
-	return -EIO;
+	return bpctl->functions[selector].name;
 }
 
-//AH: Set the specified GPIO's output state
-static void bflb_gpio_set(struct gpio_chip *chip, unsigned int offset,
-		int value)
+static int bflb_pinmux_get_function_groups(struct pinctrl_dev *pctldev,
+		unsigned int selector, const char * const **groups, unsigned int *num_groups)
 {
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(chip);
-
-	bflb_gpio_set_reg(pctl, offset, REG_GPIOx_O, value ?
-		FIELD_PREP(REG_GPIOx_O, 1) : 0);
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
+	struct bflb_pinfunction *func = &bpctl->functions[selector];
 
-	dev_dbg(pctl->dev, "Pin %u set to value %u", offset, value);
+	*groups = func->groups;
+	*num_groups = func->ngroups;
+	return 0;
 }
 
-//AH: Set the specified gpio direction to input
-static int bflb_gpio_direction_input(struct gpio_chip *chip,
-		unsigned int offset)
+static int bflb_pinmux_set(struct pinctrl_dev *pctldev, unsigned int selector,
+		unsigned int group)
 {
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(chip);
-
-	bflb_gpio_set_reg(pctl, offset, REG_GPIOx_OE | REG_GPIOx_IE | REG_GPIOx_SMT,
-		FIELD_PREP(REG_GPIOx_OE, 0) | FIELD_PREP(REG_GPIOx_IE, 1) |
-		FIELD_PREP(REG_GPIOx_SMT, 1));
+	unsigned int i;
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
+	struct bflb_pinfunction *func = &bpctl->functions[selector];
+	struct bflb_pingroup *grp = &bpctl->groups[group];
 
-	dev_dbg(pctl->dev, "Pin %u set to direction input", offset);
+	for (i = 0; i < grp->npins; i++) {
+		regmap_update_bits(bpctl->map, REG_PIN(grp->pins[i]), REG_PIN_FUNC_SEL,
+				FIELD_PREP(REG_PIN_FUNC_SEL, func->val));
 
+		dev_dbg(bpctl->dev, "PIN%u set to function %u", grp->pins[i], func->val);
+	}
 	return 0;
 }
 
-//AH: Set the specified gpio direction to output
-static int bflb_gpio_direction_output(struct gpio_chip *chip,
-		unsigned int offset, int value)
+static int bflb_pinmux_gpio_request(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range, unsigned int offset)
 {
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(chip);
+	int err;
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
 
-	bflb_gpio_set_reg(pctl, offset, REG_GPIOx_PD | REG_GPIOx_PU | REG_GPIOx_OE |
-		REG_GPIOx_IE | REG_GPIOx_SMT | REG_GPIOx_MODE,
-		FIELD_PREP(REG_GPIOx_PD, 0) | FIELD_PREP(REG_GPIOx_PU, 0) |
-		FIELD_PREP(REG_GPIOx_OE, 1) | FIELD_PREP(REG_GPIOx_IE, 0) |
-		FIELD_PREP(REG_GPIOx_SMT, 1) | FIELD_PREP(REG_GPIOx_MODE, 0));
+	err = regmap_update_bits(bpctl->map, REG_PIN(offset), REG_PIN_FUNC_SEL,
+			FIELD_PREP(REG_PIN_FUNC_SEL, BFLB_PINMUX_FUNC_GPIO));
+	dev_dbg(bpctl->dev, "PIN%u is set to function GPIO", offset);
+	return err;
+}
 
-	dev_dbg(pctl->dev, "Pin %u set to direction output", offset);
+static void bflb_pinmux_gpio_free(struct pinctrl_dev *pctldev,
+				   struct pinctrl_gpio_range *range,
+				   unsigned int offset)
+{
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
 
-	bflb_gpio_set(chip, offset, value); //Set the initially passed value
+	dev_dbg(bpctl->dev, "PIN%u function GPIO is freed", offset);
+}
 
-	return 0;
+static int bflb_pinmux_gpio_set_direction(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range, unsigned int offset, bool input)
+{
+	int err;
+	unsigned long mask, val, reg = REG_PIN(offset);
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
+
+	if (input) {
+		mask = REG_PIN_OE | REG_PIN_IE | REG_PIN_SMT;
+		val = FIELD_PREP(REG_PIN_OE, 0) | FIELD_PREP(REG_PIN_IE, 1) |
+				FIELD_PREP(REG_PIN_SMT, 1);
+		err = regmap_update_bits(bpctl->map, reg, mask, val);
+	} else {
+		mask = REG_PIN_OE | REG_PIN_IE | REG_PIN_SMT | REG_PIN_MODE_MASK,
+		val = FIELD_PREP(REG_PIN_PD, 0) | FIELD_PREP(REG_PIN_PU, 0) |
+				FIELD_PREP(REG_PIN_OE, 1) | FIELD_PREP(REG_PIN_IE, 0) |
+				FIELD_PREP(REG_PIN_SMT, 1) | FIELD_PREP(REG_PIN_MODE_MASK, 0);
+		err = regmap_update_bits(bpctl->map, reg, mask, val);
+	}
+	dev_dbg(bpctl->dev, "PIN%u set to direction %s",
+			offset, input ? "input" : "output");
+	return err;
 }
 
-//AH: Configure pin electrical characteristics
-static int bflb_gpio_set_config(struct gpio_chip *chip, unsigned int offset,
-		unsigned long config)
+static const struct pinmux_ops bflb_pinmux_ops = {
+	.get_functions_count = bflb_pinmux_get_functions_count,
+	.get_function_name = bflb_pinmux_get_function_name,
+	.get_function_groups = bflb_pinmux_get_function_groups,
+	.set_mux = bflb_pinmux_set,
+	.gpio_request_enable = bflb_pinmux_gpio_request,
+	.gpio_disable_free = bflb_pinmux_gpio_free,
+	.gpio_set_direction = bflb_pinmux_gpio_set_direction,
+	.strict = true,
+};
+
+static int bflb_pinconf_get(struct pinctrl_dev *pctldev,
+			       unsigned int pin, unsigned long *config)
 {
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(chip);
-	enum pin_config_param param = pinconf_to_config_param(config);
-	unsigned int arg = pinconf_to_config_argument(config);
+	u32 arg;
+	unsigned int val;
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param = pinconf_to_config_param(*config);
 
+	regmap_read(bpctl->map, REG_PIN(pin), &val);
 	switch (param) {
-	case PIN_CONFIG_BIAS_DISABLE:
-		bflb_gpio_set_reg(pctl, offset, REG_GPIOx_PD | REG_GPIOx_PU,
-			FIELD_PREP(REG_GPIOx_PD, 0) | FIELD_PREP(REG_GPIOx_PU, 0));
-		break;
-
-	case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
-		if (arg) {
-			bflb_gpio_set_reg(pctl, offset, REG_GPIOx_PD | REG_GPIOx_PU,
-				FIELD_PREP(REG_GPIOx_PD, 0) | FIELD_PREP(REG_GPIOx_PU, 0));
-		}
+	case PIN_CONFIG_OUTPUT_ENABLE:
+		arg = FIELD_GET(REG_PIN_OE, val);
 		break;
 
-	case PIN_CONFIG_BIAS_PULL_DOWN:
-		if (arg) {
-			bflb_gpio_set_reg(pctl, offset, REG_GPIOx_PD | REG_GPIOx_PU,
-				FIELD_PREP(REG_GPIOx_PD, 1) | FIELD_PREP(REG_GPIOx_PU, 0));
-		}
+	case PIN_CONFIG_OUTPUT:
+		arg = FIELD_GET(REG_PIN_OUT_HIGH, val);
 		break;
 
-	case PIN_CONFIG_BIAS_PULL_UP:
-		if (arg) {
-			bflb_gpio_set_reg(pctl, offset, REG_GPIOx_PD | REG_GPIOx_PU,
-				FIELD_PREP(REG_GPIOx_PD, 0) | FIELD_PREP(REG_GPIOx_PU, 1));
-		}
+	case PIN_CONFIG_INPUT_ENABLE:
+		arg = FIELD_GET(REG_PIN_IE, val);
 		break;
 
-	case PIN_CONFIG_BIAS_HIGH_IMPEDANCE:
-		bflb_gpio_set_reg(pctl, offset, REG_GPIOx_PD | REG_GPIOx_PU |
-			REG_GPIOx_IE | REG_GPIOx_OE, FIELD_PREP(REG_GPIOx_PD, 0) |
-			FIELD_PREP(REG_GPIOx_PU, 0) | FIELD_PREP(REG_GPIOx_IE, 0) |
-			FIELD_PREP(REG_GPIOx_OE, 0));
+	case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
+		arg = FIELD_GET(REG_PIN_SMT, val);
 		break;
 
-	case PIN_CONFIG_INPUT_ENABLE:
-		bflb_gpio_set_reg(pctl, offset, REG_GPIOx_IE,
-			FIELD_PREP(REG_GPIOx_IE, !!arg));
+	case PIN_CONFIG_BIAS_PULL_UP:
+		arg = FIELD_GET(REG_PIN_PU, val);
 		break;
 
-	case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
-		bflb_gpio_set_reg(pctl, offset, REG_GPIOx_SMT,
-			FIELD_PREP(REG_GPIOx_SMT, !!arg));
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+		arg = FIELD_GET(REG_PIN_PD, val);
 		break;
 
-	case PIN_CONFIG_OUTPUT:
-		bflb_gpio_set_reg(pctl, offset, REG_GPIOx_OE | REG_GPIOx_O,
-			FIELD_PREP(REG_GPIOx_OE, 1) | FIELD_PREP(REG_GPIOx_O, !!arg));
+	case PIN_CONFIG_BIAS_DISABLE:
+		arg = !FIELD_GET(REG_PIN_PD | REG_PIN_PU, val);
 		break;
 
-	case PIN_CONFIG_OUTPUT_ENABLE:
-		bflb_gpio_set_reg(pctl, offset, REG_GPIOx_OE,
-			FIELD_PREP(REG_GPIOx_OE, 1));
+	case PIN_CONFIG_DRIVE_STRENGTH:
+		arg = FIELD_GET(REG_PIN_DRV, val);
 		break;
 
-	default: return -ENOTSUPP;
+	default:
+		return -ENOTSUPP;
 	}
 
-	dev_dbg(pctl->dev, "Pin %u config set to %lu (param %u, arg %u)", offset,
-		config, param, arg);
+	*config = pinconf_to_config_packed(param, arg);
+	return 0;
+}
+
+static int bflb_pinconf_set(struct pinctrl_dev *pctldev,
+		unsigned int pin, unsigned long *configs, unsigned int num_configs)
+{
+	u32 arg;
+	unsigned int i, reg;
+	enum pin_config_param param;
+	struct bflb_pinctrl_info *bpctl = pinctrl_dev_get_drvdata(pctldev);
+
+	reg = REG_PIN(pin);
+	for (i = 0; i < num_configs; i++) {
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		dev_dbg(bpctl->dev, "PIN%u config set to %lu (param %u, arg %u)",
+				pin, configs[i], param, arg);
+		switch (param) {
+		case PIN_CONFIG_OUTPUT:
+			regmap_update_bits(bpctl->map, reg, REG_PIN_OE | REG_PIN_OUT_HIGH,
+				FIELD_PREP(REG_PIN_OE, 1) | FIELD_PREP(REG_PIN_OUT_HIGH, !!arg));
+			break;
+
+		case PIN_CONFIG_OUTPUT_ENABLE:
+			regmap_update_bits(bpctl->map, reg, REG_PIN_OE,
+					FIELD_PREP(REG_PIN_OE, !!arg));
+			break;
+
+		case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
+			regmap_update_bits(bpctl->map, reg, REG_PIN_SMT,
+					FIELD_PREP(REG_PIN_SMT, !!arg));
+			break;
+
+		case PIN_CONFIG_INPUT_ENABLE:
+			regmap_update_bits(bpctl->map, reg, REG_PIN_IE,
+					FIELD_PREP(REG_PIN_IE, !!arg));
+			break;
+
+		case PIN_CONFIG_BIAS_PULL_UP:
+			if (arg) {
+				regmap_update_bits(bpctl->map, reg, REG_PIN_PU | REG_PIN_PD,
+						FIELD_PREP(REG_PIN_PU, 1) | FIELD_PREP(REG_PIN_PD, 0));
+			}
+			break;
+
+		case PIN_CONFIG_BIAS_PULL_DOWN:
+			if (arg) {
+				regmap_update_bits(bpctl->map, reg, REG_PIN_PU | REG_PIN_PD,
+						FIELD_PREP(REG_PIN_PD, 1) | FIELD_PREP(REG_PIN_PU, 0));
+			}
+			break;
 
+		case PIN_CONFIG_BIAS_DISABLE:
+			if (arg) {
+				regmap_update_bits(bpctl->map, reg, REG_PIN_PU | REG_PIN_PD,
+						FIELD_PREP(REG_PIN_PD, 0) | FIELD_PREP(REG_PIN_PU, 0));
+			}
+			break;
+
+		case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
+			if (arg) {
+				regmap_update_bits(bpctl->map, reg, REG_PIN_PU | REG_PIN_PD,
+						FIELD_PREP(REG_PIN_PD, 0) | FIELD_PREP(REG_PIN_PU, 0));
+			}
+			break;
+
+		case PIN_CONFIG_DRIVE_STRENGTH:
+			regmap_update_bits(bpctl->map, reg, REG_PIN_DRV,
+					FIELD_PREP(REG_PIN_DRV, arg));
+			break;
+
+		case PIN_CONFIG_BIAS_HIGH_IMPEDANCE:
+			if (arg) {
+				regmap_update_bits(bpctl->map, reg, REG_PIN_PD | REG_PIN_PU |
+						REG_PIN_IE | REG_PIN_OE, FIELD_PREP(REG_PIN_PD, 0) |
+						FIELD_PREP(REG_PIN_PU, 0) | FIELD_PREP(REG_PIN_IE, 0) |
+						FIELD_PREP(REG_PIN_OE, 0));
+			}
+			break;
+
+		default:
+			return -ENOTSUPP;
+		}
+	}
 	return 0;
 }
 
-/* IRQ chip functions */
+static const struct pinconf_ops bflb_pinconf_ops = {
+	.pin_config_set = bflb_pinconf_set,
+	.pin_config_get = bflb_pinconf_get,
+	.is_generic = true,
+};
+
+/* GPIO chip functions */
+static int bflb_gpio_get_direction(struct gpio_chip *chip,
+		unsigned int offset)
+{
+	unsigned int reg;
+	struct bflb_pinctrl_info *pctl = gpiochip_get_data(chip);
+
+	regmap_read(pctl->map, REG_PIN(offset), &reg);
+	if (FIELD_GET(REG_PIN_OE, reg) == 1 &&
+			FIELD_GET(REG_PIN_IE, reg) == 0) {
+		return GPIO_LINE_DIRECTION_OUT;
+	} else if (FIELD_GET(REG_PIN_IE, reg) == 1 &&
+			FIELD_GET(REG_PIN_OE, reg) == 0) {
+		return GPIO_LINE_DIRECTION_IN;
+	}
+
+	return -EIO;
+}
+
+static int bflb_gpio_get(struct gpio_chip *chip, unsigned int offset)
+{
+	unsigned int reg;
+	struct bflb_pinctrl_info *pctl = gpiochip_get_data(chip);
+
+	regmap_read(pctl->map, REG_PIN(offset), &reg);
+	if (FIELD_GET(REG_PIN_OE, reg) == 1 &&
+			FIELD_GET(REG_PIN_IE, reg) == 0) {
+		reg = readl_relaxed(pctl->base + REG_PIN(offset));
+		return !!(reg & REG_PIN_OUT_HIGH);
+	} else if (FIELD_GET(REG_PIN_IE, reg) == 1 &&
+			FIELD_GET(REG_PIN_OE, reg) == 0) {
+		reg = readl_relaxed(pctl->base + REG_PIN(offset));
+		return !!(reg & REG_PIN_IN_HIGH);
+	}
+
+	return -EIO;
+}
+
+/*
+ * Note: offset is the local GPIO number of the current chip, not the
+ * global GPIO number (which is chip->base + offset), nor pin number.
+ * Thus GPIO set function does not work if the pin-base in gpio-ranges
+ * (gpio-ranges = <&pinctrl gpio-base pin-base num>)is not zero, because
+ * the wrong register would be programmed.
+ *
+ * The rigorous method:
+ *		gpio = chip->base + offset;
+ *		pin = gpio_to_pin(gpio);
+ *		reg_addr = pin_to_reg(pin);
+ *		write register(reg_addr, val);
+ */
+static void bflb_gpio_set(struct gpio_chip *chip, unsigned int offset,
+		int value)
+{
+	struct bflb_pinctrl_info *bpctl = gpiochip_get_data(chip);
+
+	regmap_update_bits(bpctl->map, REG_PIN(offset), REG_PIN_OUT_HIGH,
+						FIELD_PREP(REG_PIN_OUT_HIGH, !!value));
+	dev_dbg(bpctl->dev, "PIN%u set to value %u", offset, value);
+}
+
+static int bflb_gpio_direction_input(struct gpio_chip *chip,
+		unsigned int offset)
+{
+	int err;
+	struct bflb_pinctrl_info *bpctl = gpiochip_get_data(chip);
+
+	err = pinctrl_gpio_direction_input(chip->base + offset);
+	dev_dbg(bpctl->dev, "GPIO%u set to direction input", chip->base + offset);
+	return err;
+}
+
+static int bflb_gpio_direction_output(struct gpio_chip *chip,
+		unsigned int offset, int value)
+{
+	int err;
+	struct bflb_pinctrl_info *pctl = gpiochip_get_data(chip);
+
+	err = pinctrl_gpio_direction_output(chip->base + offset);
+	if (err)
+		return err;
+	bflb_gpio_set(chip, offset, value);
+	dev_dbg(pctl->dev, "GPIO%u set to direction output", chip->base + offset);
+	return 0;
+}
 
-//AH: Clear the interrupt for the specified GPIO
 static void bflb_gpio_irq_ack(struct irq_data *data)
 {
-	struct bflb_gpio_pinctrl *pctl =
+	irq_hw_number_t irq = irqd_to_hwirq(data);
+	struct bflb_pinctrl_info *bpctl =
 			gpiochip_get_data(irq_data_get_irq_chip_data(data));
 
-	bflb_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_INT_CLR,
-	    FIELD_PREP(REG_GPIOx_INT_CLR, 1));
-
-	bflb_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_INT_CLR,
-	    FIELD_PREP(REG_GPIOx_INT_CLR, 0));
+	regmap_update_bits(bpctl->map, REG_PIN(irq), REG_PIN_INT_CLR,
+			FIELD_PREP(REG_PIN_INT_CLR, 1));
+	regmap_update_bits(bpctl->map, REG_PIN(irq), REG_PIN_INT_CLR,
+			FIELD_PREP(REG_PIN_INT_CLR, 0));
 
-	dev_dbg(pctl->dev, "Pin %lu IRQ ACK", data->hwirq);
+	dev_dbg(bpctl->dev, "GPIO %lu IRQ ACK", irq);
 }
 
-//AH: Find the correct value for the type of interrupts we want to receive
-//for a GPIO
 static unsigned int bflb_gpio_irq_type(unsigned int type)
 {
-	unsigned int selected;
+	unsigned int mode;
 
 	switch (type & IRQ_TYPE_SENSE_MASK) {
-
 	case IRQ_TYPE_EDGE_RISING:
-		selected = BFLB_IRQ_MODE_SYNC_EDGE_RISING;
+		mode = BFLB_IRQ_MODE_SYNC_EDGE_RISING;
 		break;
 
 	case IRQ_TYPE_EDGE_FALLING:
-		selected = BFLB_IRQ_MODE_SYNC_EDGE_FALLING;
+		mode = BFLB_IRQ_MODE_SYNC_EDGE_FALLING;
 		break;
 
 	case IRQ_TYPE_EDGE_BOTH:
-		selected = BFLB_IRQ_MODE_SYNC_EDGE_BOTH;
+		mode = BFLB_IRQ_MODE_SYNC_EDGE_BOTH;
 		break;
 
 	case IRQ_TYPE_LEVEL_HIGH:
-		selected = BFLB_IRQ_MODE_SYNC_LEVEL_HIGH;
+		mode = BFLB_IRQ_MODE_SYNC_LEVEL_HIGH;
 		break;
 
 	case IRQ_TYPE_LEVEL_LOW:
-		selected = BFLB_IRQ_MODE_SYNC_LEVEL_LOW;
+		mode = BFLB_IRQ_MODE_SYNC_LEVEL_LOW;
 		break;
 
-	//No "off" available on BL808, set to default IRQ_TYPE_EDGE_FALLING and
-	//then we'll need to mask
 	default:
-		selected = BFLB_IRQ_MODE_SYNC_EDGE_FALLING;
+		mode = BFLB_IRQ_MODE_SYNC_EDGE_FALLING;
 		break;
 	}
 
-	return selected;
+	return mode;
 }
 
-//AH: Disable the specified GPIO's interrupt
 static void bflb_gpio_irq_mask(struct irq_data *data)
 {
+	irq_hw_number_t irq = irqd_to_hwirq(data);
 	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(gc);
+	struct bflb_pinctrl_info *bpctl = gpiochip_get_data(gc);
 
-	bflb_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_INT_MASK,
-	    FIELD_PREP(REG_GPIOx_INT_MASK, 1));
+	regmap_update_bits(bpctl->map, REG_PIN(irq), REG_PIN_INT_MASK,
+		FIELD_PREP(REG_PIN_INT_MASK, 1));
+	clear_bit(irq, bpctl->unmasked_irqs);
+	gpiochip_disable_irq(gc, irq);
 
-	clear_bit(data->hwirq, pctl->irqsunmasked);
-	gpiochip_disable_irq(gc, data->hwirq);
-
-	dev_dbg(pctl->dev, "Pin %lu IRQ Mask", data->hwirq);
+	dev_dbg(bpctl->dev, "GPIO%lu IRQ masked", irq);
 }
 
-//AH: Enable the specified GPIO's interrupt
 static void bflb_gpio_irq_unmask(struct irq_data *data)
 {
+	irq_hw_number_t irq = irqd_to_hwirq(data);
 	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(gc);
+	struct bflb_pinctrl_info *bpctl = gpiochip_get_data(gc);
 	unsigned int irqtype = bflb_gpio_irq_type(irqd_get_trigger_type(data));
 
-	gpiochip_enable_irq(gc, data->hwirq);
-	set_bit(data->hwirq, pctl->irqsunmasked);
-
-	bflb_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_INT_MASK |
-		REG_GPIOx_INT_MODE_SET, FIELD_PREP(REG_GPIOx_INT_MASK, 0) |
-		FIELD_PREP(REG_GPIOx_INT_MODE_SET, irqtype));
+	gpiochip_enable_irq(gc, irq);
+	set_bit(irq, bpctl->unmasked_irqs);
+	regmap_update_bits(bpctl->map, REG_PIN(irq), REG_PIN_INT_MASK |
+		REG_PIN_INT_MODE_SET, FIELD_PREP(REG_PIN_INT_MASK, 0) |
+		FIELD_PREP(REG_PIN_INT_MODE_SET, irqtype));
 
-	dev_dbg(pctl->dev, "Pin %lu IRQ Unmask", data->hwirq);
+	dev_dbg(bpctl->dev, "GPIO%lu IRQ unmasked", irq);
 }
 
-//AH: Initialise the specified GPIO's interrupt
 static unsigned int bflb_gpio_irq_startup(struct irq_data *data)
 {
+	irq_hw_number_t irq = irqd_to_hwirq(data);
 	struct gpio_chip *chip = irq_data_get_irq_chip_data(data);
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(chip);
-
-	bflb_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_INT_CLR,
-	    FIELD_PREP(REG_GPIOx_INT_CLR, 1));
-
-	bflb_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_INT_CLR,
-	    FIELD_PREP(REG_GPIOx_INT_CLR, 0));
+	struct bflb_pinctrl_info *bpctl = gpiochip_get_data(chip);
 
+	regmap_update_bits(bpctl->map, REG_PIN(irq), REG_PIN_INT_CLR,
+			FIELD_PREP(REG_PIN_INT_CLR, 1));
+	regmap_update_bits(bpctl->map, REG_PIN(irq), REG_PIN_INT_CLR,
+			FIELD_PREP(REG_PIN_INT_CLR, 0));
 	bflb_gpio_irq_unmask(data);
 
-	dev_dbg(pctl->dev, "Pin %lu IRQ Started", data->hwirq);
-
+	dev_dbg(bpctl->dev, "PIN%lu IRQ started", irq);
 	return 0;
 }
 
-//AH: Set the specified GPIO's interrupt mode
 static int bflb_gpio_irq_set_type(struct irq_data *data, unsigned int type)
 {
-	struct bflb_gpio_pinctrl *pctl =
-			gpiochip_get_data(irq_data_get_irq_chip_data(data));
-
+	struct bflb_pinctrl_info *bpctl;
+	irq_hw_number_t irq = irqd_to_hwirq(data);
 	unsigned int irqtype = bflb_gpio_irq_type(type);
 
 	if (irqtype == 0)
 		return -EINVAL;
 
-	bflb_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_INT_MODE_SET,
-		FIELD_PREP(REG_GPIOx_INT_MODE_SET, irqtype));
-
+	bpctl = gpiochip_get_data(irq_data_get_irq_chip_data(data));
+	regmap_update_bits(bpctl->map, REG_PIN(irq), REG_PIN_INT_MODE_SET,
+			FIELD_PREP(REG_PIN_INT_MODE_SET, irqtype));
 	if (type & IRQ_TYPE_LEVEL_MASK)
 		irq_set_handler_locked(data, handle_level_irq);
 	else
 		irq_set_handler_locked(data, handle_edge_irq);
 
-	dev_dbg(pctl->dev, "Pin %lu IRQ type set to %u", data->hwirq, irqtype);
-
+	dev_dbg(bpctl->dev, "GPIO%lu IRQ type set to %u", irq, irqtype);
 	return 0;
 }
 
-//AH: Handle GPIO interrupts on this controller
+/* handle GPIO interrupts on this controller */
 static void bflb_gpio_irq_handler(struct irq_desc *desc)
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
-	u8 *grpp = irq_desc_get_handler_data(desc);
-	struct bflb_gpio_pinctrl *pctl;
-	unsigned int pinh;
+	struct bflb_pinctrl_info *pctl = irq_desc_get_handler_data(desc);
+	unsigned int gpio;
 	unsigned long reg;
 	struct gpio_chip *gc;
 
-	pctl = container_of(grpp - *grpp, typeof(*pctl), irqgrps[0]);
 	gc = &pctl->gpio_chip;
-
 	chained_irq_enter(chip, desc);
-
-	//We must go through each individual GPIO register to read its interrupt
-	//status. There is no gpio_cfg128+ helper register for interrupts
-	//(looking at BL808 RM)
-	for (pinh = 0; pinh < gc->ngpio; pinh += 1) {
-		if (test_bit(pinh, pctl->irqsunmasked)) {
-			dev_dbg(pctl->dev, "Reading IRQ status of pin %u", pinh);
-
-			reg = readl_relaxed(pctl->base + REG_GPIO(pinh));
-
-			if (reg & REG_GPIOx_INT_STAT) {
-				generic_handle_domain_irq(gc->irq.domain, pinh);
-				dev_dbg(pctl->dev, "Pin %u IRQ Fire", pinh);
+	/*
+	 * we must go through each individual GPIO register to read its interrupt
+	 * status. There is no helper register for all pending interrupts.
+	 */
+	for (gpio = 0; gpio < gc->ngpio; gpio++) {
+		if (test_bit(gpio, pctl->unmasked_irqs)) {
+			dev_dbg(pctl->dev, "reading IRQ status of GPIO%u", gpio);
+
+			reg = readl_relaxed(pctl->base + REG_PIN(gpio));
+			if (reg & REG_PIN_INT_STAT) {
+				generic_handle_domain_irq(gc->irq.domain, gpio);
+				dev_dbg(pctl->dev, "GPIO%u IRQ is set", gpio);
 			}
 		} else {
-			dev_dbg(pctl->dev, "Ignoring IRQ status of masked pin %u", pinh);
+			dev_dbg(pctl->dev, "ignoring IRQ status of masked GPIO%u", gpio);
 		}
 	}
-
 	chained_irq_exit(chip, desc);
 }
 
@@ -506,214 +778,286 @@ static const struct irq_chip bflb_gpio_irqchip = {
 	GPIOCHIP_IRQ_RESOURCE_HELPERS,
 };
 
-static int bflb_gpio_request(struct gpio_chip *chip, unsigned int offset)
+static int bflb_gpio_register(struct bflb_pinctrl_info *pctl)
 {
 	int ret;
-	struct bflb_gpio_pinctrl *pctl = gpiochip_get_data(chip);
-
-	ret = pinctrl_gpio_request(chip->base + offset);
-
-	if (ret)
-		return ret;
-
-	bflb_gpio_set_reg(pctl, offset, REG_GPIOx_FUNC_SEL,
-		FIELD_PREP(REG_GPIOx_FUNC_SEL, 11/*SWGPIO*/));
-
-	dev_dbg(pctl->dev, "Pin %u set to function GPIO as part of request",
-			offset);
-
-	return 0;
-}
-
-/* Probe & register */
-
-static int bflb_gpio_register(struct bflb_gpio_pinctrl *pctl)
-{
+	struct device *dev = pctl->dev;
 	struct gpio_irq_chip *girq = &pctl->gpio_chip.irq;
-	void **irq_data = NULL;
-	int ret;
+	struct platform_device *pdev = to_platform_device(dev);
+	unsigned int npins = pctl->pinctrl_desc.npins;
 
-	pctl->gpio_chip.label = dev_name(pctl->dev);
-	pctl->gpio_chip.request = bflb_gpio_request;
+	pctl->unmasked_irqs = devm_bitmap_zalloc(&pdev->dev, npins, GFP_KERNEL);
+	if (!pctl->unmasked_irqs)
+		return -ENOMEM;
+
+	pctl->gpio_chip.label = dev_name(dev);
+	pctl->gpio_chip.request = gpiochip_generic_request;
 	pctl->gpio_chip.free = gpiochip_generic_free;
 	pctl->gpio_chip.get_direction = bflb_gpio_get_direction;
 	pctl->gpio_chip.direction_input = bflb_gpio_direction_input;
 	pctl->gpio_chip.direction_output = bflb_gpio_direction_output;
 	pctl->gpio_chip.get = bflb_gpio_get;
 	pctl->gpio_chip.set = bflb_gpio_set;
-	pctl->gpio_chip.set_config = bflb_gpio_set_config;
+	pctl->gpio_chip.set_config = gpiochip_generic_config;
 	pctl->gpio_chip.base = -1;
-	pctl->gpio_chip.ngpio = pctl->pinctrl_desc.npins;
-	pctl->gpio_chip.parent = pctl->dev;
+	pctl->gpio_chip.ngpio = npins;
+	pctl->gpio_chip.parent = dev;
+
+	if (of_property_present(dev_of_node(dev), "interrupt-controller")) {
+		ret = platform_irq_count(pdev);
+		if (ret > 0)
+			girq->num_parents = ret;
+		else
+			girq->num_parents = 0;
+	}
 
 	if (girq->num_parents) {
 		int i;
 
 		gpio_irq_chip_set_chip(girq, &bflb_gpio_irqchip);
-
 		girq->parent_handler = bflb_gpio_irq_handler;
 
-		girq->parents = kmalloc_array(girq->num_parents, sizeof(*girq->parents),
-				GFP_KERNEL);
-		irq_data = kmalloc_array(girq->num_parents, sizeof(*irq_data),
-				GFP_KERNEL);
-
-		if (!girq->parents || !irq_data) {
-			ret = -ENOMEM;
-			goto out_free_irq_data;
-		}
+		girq->parents = devm_kmalloc_array(dev, girq->num_parents,
+				sizeof(*girq->parents), GFP_KERNEL);
+		if (!girq->parents)
+			return -ENOMEM;
 
 		for (i = 0; i < girq->num_parents; i++) {
-			ret = platform_get_irq(to_platform_device(pctl->dev), i);
-
+			ret = platform_get_irq(pdev, i);
 			if (ret < 0)
-				goto out_free_irq_data;
+				return ret;
 
 			girq->parents[i] = ret;
-			pctl->irqgrps[i] = i;
-			irq_data[i] = &pctl->irqgrps[i];
 		}
 
-		girq->parent_handler_data_array = irq_data;
-		girq->per_parent_data = true;
+		girq->parent_handler_data = pctl;
 		girq->default_type = IRQ_TYPE_NONE;
 		girq->handler = handle_level_irq;
 	}
 
-	ret = devm_gpiochip_add_data(pctl->dev, &pctl->gpio_chip, pctl);
+	return devm_gpiochip_add_data(dev, &pctl->gpio_chip, pctl);
+}
 
-out_free_irq_data:
-	kfree(girq->parents);
-	kfree(irq_data);
+static int bflb_pinctrl_parse_group(struct bflb_pinctrl_info *bpctl,
+		struct bflb_pingroup *grp, struct device_node *np, int *has_func)
+{
+	int err, size;
+	unsigned int i;
+	const __be32 *list;
+
+	*has_func = 1;
+	grp->fn_val = BFLB_PINMUX_FUNC_NONE;
+	if (of_property_read_u32(np, "bflb,pin-function", &grp->fn_val))
+		*has_func = 0;
+
+	grp->name = np->name;
+	/* the binding format is bflb,pins = <bank pin config> */
+	list = of_get_property(np, "bflb,pins", &size);
+	if (!list)
+		return dev_err_probe(bpctl->dev, -EINVAL, "bflb,pins is not found\n");
+
+	size /= sizeof(*list);
+	if (!size || size % 3)
+		return dev_err_probe(bpctl->dev, -EINVAL, "invalid binding format\n");
+
+	grp->npins = size / 3;
+	grp->pins = devm_kcalloc(bpctl->dev, grp->npins, sizeof(*grp->pins),
+							 GFP_KERNEL);
+	if (!grp->pins)
+		return -ENOMEM;
+	grp->pinconf = devm_kcalloc(bpctl->dev, grp->npins, sizeof(*grp->pinconf),
+								GFP_KERNEL);
+	if (!grp->pinconf)
+		return -ENOMEM;
 
-	return ret;
+	dev_dbg(bpctl->dev, "parsing group %s, npins %lu\n", grp->name, grp->npins);
+	/* parse each pin of this group */
+	for (i = 0; i < grp->npins; i++) {
+		phandle cfg_phandle;
+		struct device_node *np_config;
+
+		/* now the bank number is ignored */
+		list++;
+		/* here is the pin number */
+		grp->pins[i] = be32_to_cpu(*list++);
+		/* and phandle of the pin configurations */
+		cfg_phandle = be32_to_cpup(list++);
+		np_config = of_find_node_by_phandle(cfg_phandle);
+		if (!np_config) {
+			return dev_err_probe(bpctl->dev, -EINVAL,
+					"invalid pin cfg phandle %u\n", cfg_phandle);
+		}
+
+		err = pinconf_generic_parse_dt_config(np_config, NULL,
+				&grp->pinconf[i].configs, &grp->pinconf[i].nconfigs);
+		of_node_put(np_config);
+		if (err)
+			return err;
+	}
+	return 0;
 }
 
-static int bflb_gpio_pinctrl_probe(struct platform_device *pdev)
+static int bflb_pinctrl_function_add_group(struct bflb_pinctrl_info *bpctl,
+		struct bflb_pinfunction *func, struct bflb_pingroup *grp)
 {
-	struct bflb_gpio_pinctrl *pctl;
-	struct pinctrl_pin_desc *pins;
+	if (func->ngroups >= func->ncap) {
+		func->ncap++;
+		func->groups = devm_krealloc_array(bpctl->dev, func->groups,
+						func->ncap, sizeof(*func->groups), GFP_KERNEL);
+		if (!func->groups)
+			return -ENOMEM;
+	}
 
-	unsigned int npins;
-	const char **pin_names;
-	unsigned int *pin_nums;
-	unsigned int i, nirqs = 0;
-	int res;
+	func->groups[func->ngroups++] = grp->name;
+	return 0;
+}
 
-	if (of_property_read_bool(pdev->dev.of_node, "interrupt-controller")) {
-		res = platform_irq_count(pdev);
-		if (res > 0)
-			nirqs = res;
-	}
+static int bflb_pinctrl_create_functions(struct bflb_pinctrl_info *bpctl)
+{
+	int i;
 
-	pctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);
+	bpctl->nfunctions = ARRAY_SIZE(bl808_functions);
+	bpctl->functions = devm_kcalloc(bpctl->dev, bpctl->nfunctions,
+									sizeof(*bpctl->functions), GFP_KERNEL);
+	if (!bpctl->functions)
+		return -ENOMEM;
 
-	if (!pctl)
+	for (i = 0; i < bpctl->nfunctions; i++) {
+		bpctl->functions[i].name = bl808_functions[i].name;
+		bpctl->functions[i].val = bl808_functions[i].val;
+		bpctl->functions[i].ngroups = 0;
+		bpctl->functions[i].ncap = 0;
+	}
+	return 0;
+}
+
+static int bflb_pinctrl_parse_dt(struct bflb_pinctrl_info *bpctl)
+{
+	int err, ngroups = 0;
+	struct device_node *child;
+	struct device *dev = bpctl->dev;
+	struct bflb_pingroup *grp;
+	struct bflb_pinfunction *func;
+	struct device_node *np = dev_of_node(dev);
+
+	err = bflb_pinctrl_create_functions(bpctl);
+	if (err)
+		return err;
+	/*
+	 * allocate memory with possible max size, there might be some bad configs
+	 * in device tree though.
+	 */
+	for_each_child_of_node(np, child) {
+		if (of_property_present(child, "bflb,pins"))
+			ngroups++;
+	}
+	bpctl->groups = devm_kcalloc(dev, ngroups, sizeof(*bpctl->groups),
+									GFP_KERNEL);
+	if (!bpctl->groups)
 		return -ENOMEM;
 
-	pctl->dev = &pdev->dev;
-	pctl->gpio_chip.irq.num_parents = nirqs;
+	bpctl->ngroups = 0;
+	for_each_child_of_node(np, child) {
+		/* try to parse the pin group */
+		int has_func = 0;
 
-	dev_set_drvdata(&pdev->dev, pctl);
+		if (!of_property_present(child, "bflb,pins"))
+			continue;
 
-	if (of_property_read_u32(pdev->dev.of_node, "bflb,npins", &npins))
-		return dev_err_probe(&pdev->dev, -EINVAL,
-				"bflb,npins property not found\n");
+		grp = &bpctl->groups[bpctl->ngroups];
+		err = bflb_pinctrl_parse_group(bpctl, grp, child, &has_func);
+		if (err) {
+			dev_err(bpctl->dev, "failed to parse group %s\n", child->name);
+			return err;
+		}
 
-	pctl->irqsunmasked = devm_bitmap_zalloc(&pdev->dev, npins, GFP_KERNEL);
+		bpctl->ngroups++;
+		/* adding a group without function is fine */
+		if (!has_func)
+			continue;
 
-	pins = devm_kmalloc_array(&pdev->dev, npins, sizeof(pins[0]), GFP_KERNEL);
-	pin_names = devm_kmalloc_array(&pdev->dev, npins, sizeof(pin_names[0]),
-			GFP_KERNEL);
-	pin_nums = devm_kmalloc_array(&pdev->dev, npins, sizeof(pin_nums[0]),
-			GFP_KERNEL);
+		func = bflb_pinctrl_parse_function(bpctl, grp->fn_val);
+		if (IS_ERR_OR_NULL(func)) {
+			dev_err(bpctl->dev, "wrong pinmux value 0x%x for group %s\n",
+					grp->fn_val, grp->name);
+			return -EINVAL;
+		}
 
-	if (!pins || !pin_names || !pin_nums)
+		err = bflb_pinctrl_function_add_group(bpctl, func, grp);
+		if (err) {
+			return dev_err_probe(bpctl->dev, err,
+					"function %s failed to add group %s\n", func->name, grp->name);
+		}
+	}
+
+	return 0;
+}
+
+static int bflb_pinctrl_gpio_probe(struct platform_device *pdev)
+{
+	int err;
+	struct bflb_pinctrl_info *pctl;
+
+	pctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);
+	if (!pctl)
 		return -ENOMEM;
 
-	pctl->base = devm_platform_ioremap_resource(pdev, 0);
+	pctl->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, pctl);
+	err = bflb_pinctrl_parse_dt(pctl);
+	if (err)
+		return err;
 
+	pctl->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(pctl->base))
 		return PTR_ERR(pctl->base);
 
 	pctl->map = devm_regmap_init_mmio(&pdev->dev, pctl->base, &regmap_config);
-
-	if (IS_ERR(pctl->map))
+	if (IS_ERR(pctl->map)) {
 		return dev_err_probe(&pdev->dev, PTR_ERR(pctl->map),
 				"Failed to create regmap\n");
-
-	for (i = 0; i < npins; i++) {
-		pins[i].number = i;
-		pins[i].name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "GPIO%u", i);
-		pins[i].drv_data = pctl;
-		pin_names[i] = pins[i].name;
-		pin_nums[i] = i;
 	}
 
 	pctl->pinctrl_desc.name = dev_name(pctl->dev);
-	pctl->pinctrl_desc.pins = pins;
-	pctl->pinctrl_desc.npins = npins;
-	pctl->pinctrl_desc.pctlops = &bflb_gpio_pinctrl_ops;
-	pctl->pinctrl_desc.pmxops = &bflb_gpio_pinmux_ops;
-
+	pctl->pinctrl_desc.pins = bl808_pins;
+	pctl->pinctrl_desc.npins = ARRAY_SIZE(bl808_pins);
+	pctl->pinctrl_desc.pctlops = &bflb_pinctrl_ops;
+	pctl->pinctrl_desc.pmxops = &bflb_pinmux_ops;
+	pctl->pinctrl_desc.confops = &bflb_pinconf_ops;
 	pctl->pctldev =	devm_pinctrl_register(&pdev->dev, &pctl->pinctrl_desc,
 			pctl);
-
-	if (IS_ERR(pctl->pctldev))
+	if (IS_ERR(pctl->pctldev)) {
 		return dev_err_probe(&pdev->dev, PTR_ERR(pctl->pctldev),
 				"Failed to register pinctrl device.\n");
-
-	for (i = 0; i < npins; i++) {
-		res = pinctrl_generic_add_group(pctl->pctldev,
-				pins[i].name, pin_nums + i, 1, pctl);
-
-		dev_dbg(&pdev->dev, "Registered pin %s with numeric %u",
-				pins[i].name, i);
-
-		if (res < 0)
-			return dev_err_probe(pctl->dev, res, "Failed to register group");
 	}
 
-	for (i = 0; i < ARRAY_SIZE(pinmux_functions); ++i) {
-		if (pinmux_functions[i]) {
-			res = pinmux_generic_add_function(pctl->pctldev,
-					pinmux_functions[i], pin_names, npins, pctl);
+	err = bflb_gpio_register(pctl);
+	if (err)
+		return err;
 
-			dev_dbg(&pdev->dev, "Registered function %s with numeric %u",
-					pinmux_functions[i], i);
-
-			if (res < 0)
-				return dev_err_probe(pctl->dev, res,
-						"Failed to register function.");
-		}
-	}
-
-	dev_info(&pdev->dev, "Bouffalo Lab pinctrl+GPIO(+interrupt) controller - "
-			"Registered %lu function(s) for %u pin(s)",
-
-	ARRAY_SIZE(pinmux_functions), npins);
-
-	return bflb_gpio_register(pctl);
+	dev_info(&pdev->dev,
+		"Bouffalo Lab pinctrl+GPIO+interrupt controller registered\n");
+	return 0;
 }
 
-static const struct of_device_id bflb_gpio_pinctrl_of_match[] = {
-	{ .compatible = "bflb,pinctrl", },
+static const struct of_device_id bflb_pinctrl_gpio_of_ids[] = {
+	{ .compatible = "bflb,bl808-pinctrl", },
 	{ }
 };
 
-MODULE_DEVICE_TABLE(of, bflb_gpio_pinctrl_of_match);
+MODULE_DEVICE_TABLE(of, bflb_pinctrl_gpio_of_ids);
 
-static struct platform_driver bflb_gpio_pinctrl_driver = {
+static struct platform_driver bflb_pinctrl_gpio_driver = {
 	.driver = {
-		.name = "bflb-gpio-pinctrl",
-		.of_match_table = bflb_gpio_pinctrl_of_match,
+		.name = "bflb-pinctrl-gpio",
+		.of_match_table = bflb_pinctrl_gpio_of_ids,
 		.suppress_bind_attrs = true,
 	},
-	.probe = bflb_gpio_pinctrl_probe,
+	.probe = bflb_pinctrl_gpio_probe,
 };
 
-module_platform_driver(bflb_gpio_pinctrl_driver);
+module_platform_driver(bflb_pinctrl_gpio_driver);
 
-MODULE_DESCRIPTION("Bouffalo BL808 pinctrl/GPIO driver");
-MODULE_AUTHOR("Alexander Horner <contact@alexhorner.cc>");
+MODULE_DESCRIPTION("Bouffalo pinctrl-gpio driver");
+MODULE_AUTHOR("Bouffalo Lab");
 MODULE_LICENSE("GPL v2");
diff --git a/include/dt-bindings/pinctrl/pinctrl-bflb.h b/include/dt-bindings/pinctrl/pinctrl-bflb.h
new file mode 100644
index 000000000..3fbb8738e
--- /dev/null
+++ b/include/dt-bindings/pinctrl/pinctrl-bflb.h
@@ -0,0 +1,40 @@
+#ifndef __DT_BINDING_PINCTRL_BFLB__
+#define __DT_BINDING_PINCTRL_BFLB__
+
+/* pinmux functions */
+#define BFLB_PINMUX_FUNC_SDH		0
+#define BFLB_PINMUX_FUNC_SPI0		1
+#define BFLB_PINMUX_FUNC_QSPI_FLASH	2
+#define BFLB_PINMUX_FUNC_I2S		3
+#define BFLB_PINMUX_FUNC_PDM		4
+#define BFLB_PINMUX_FUNC_I2C0		5
+#define BFLB_PINMUX_FUNC_I2C1		6
+#define BFLB_PINMUX_FUNC_UART		7
+#define BFLB_PINMUX_FUNC_EMAC		8
+#define BFLB_PINMUX_FUNC_CAM		9
+#define BFLB_PINMUX_FUNC_ANALOG		10
+#define BFLB_PINMUX_FUNC_GPIO		11
+#define BFLB_PINMUX_FUNC_RF_ADDA	12
+#define BFLB_PINMUX_FUNC_SCAN_TEST	13
+#define BFLB_PINMUX_FUNC_AUDIO_TEST	14
+#define BFLB_PINMUX_FUNC_DEBUG		15
+#define BFLB_PINMUX_FUNC_PWM0		16
+#define BFLB_PINMUX_FUNC_PWM1		17
+#define BFLB_PINMUX_FUNC_MM_SPI		18
+#define BFLB_PINMUX_FUNC_MM_I2C0	19
+#define BFLB_PINMUX_FUNC_MM_I2C1	20
+#define BFLB_PINMUX_FUNC_MM_UART	21
+#define BFLB_PINMUX_FUNC_DBI_B		22
+#define BFLB_PINMUX_FUNC_DBI_C		23
+#define BFLB_PINMUX_FUNC_DPI		24
+#define BFLB_PINMUX_FUNC_JTAG_LP	25
+#define BFLB_PINMUX_FUNC_JTAG_M0	26
+#define BFLB_PINMUX_FUNC_JTAG_D0	27
+#define BFLB_PINMUX_FUNC_RF_EXT_PA	28
+#define BFLB_PINMUX_FUNC_ANT_SW		29
+#define BFLB_PINMUX_FUNC_USB_TEST	30
+#define BFLB_PINMUX_FUNC_CLOCK		31
+#define BFLB_PINMUX_FUNC_NONE   	32
+
+/* __DT_BINDING_PINCTRL_BFLB__ */
+#endif
